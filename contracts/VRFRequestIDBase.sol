// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract VRFRequestIDBase {
  /**
   * @notice returns the seed which is actually input to the VRF coordinator
   *
   * @dev To prevent repetition of VRF output due to repetition of the
   * @dev user-supplied seed, that seed is combined in a hash with the
   * @dev user-specific nonce, and the address of the consuming contract. The
   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in
   * @dev the final seed, but the nonce does protect against repetition in
   * @dev requests which are included in a single block.
   *
   * @param requester Address of the requesting contract
   * @param nonce User-specific nonce at the time of the request
   */
  function makeVRFInputSeed(
    bytes32 keyHash,
    address requester,
    uint256 nonce
  ) internal pure returns (uint256) {
    return uint256(keccak256(abi.encode(keyHash, requester, nonce)));
  }

  /**
   * @notice Returns the id for this request
   * @param keyHash The serviceAgreement ID to be used for this request
   * @param vRFInputSeed The seed to be passed directly to the VRF
   * @return The id for this request
   *
   * @dev Note that vRFInputSeed is not the seed passed by the consuming
   * @dev contract, but the one generated by makeVRFInputSeed
   */
  function makeRequestId(bytes32 keyHash, uint256 vRFInputSeed) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked(keyHash, vRFInputSeed));
  }
}
